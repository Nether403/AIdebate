[
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "3458025d-0156-46d4-b87b-978be86f4f36",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC001-Multi-Agent Debate Initialization and Execution",
    "description": "Verify that the multi-agent debate system initializes properly with selected LLM models, personas, and topics and that debates proceed with real-time streaming of arguments.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'New Debate' or 'Start New Debate' to navigate to the debate configuration form.\n        frame = context.pages[-1]\n        # Click on 'New Debate' link in the top navigation to open the debate configuration form.\n        elem = frame.locator('xpath=html/body/nav/div/div/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try scrolling down to see if the form elements are visible or try refreshing the page to reload the form.\n        await page.mouse.wheel(0, 200)\n        \n\n        # -> Click on 'Start New Debate' button to attempt to open the debate configuration form again.\n        frame = context.pages[-1]\n        # Click on 'Start New Debate' button on the homepage to open the debate configuration form.\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Debate Successfully Completed')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The multi-agent debate system did not initialize properly or debates did not proceed with real-time streaming of arguments as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819184010129//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:07.991Z",
    "modified": "2025-11-22T13:46:24.137Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "06c28aa6-e926-4121-85c9-908191043fcf",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC002-Dual Scoring System Accuracy and Consistency",
    "description": "Test that the dual scoring system correctly computes and updates Crowd Elo and AI Quality scores using Glicko-2 algorithm and detects controversy and Charismatic Liar Index correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Start New Debate' to simulate a complete debate with crowd votes and AI judge evaluations.\n        frame = context.pages[-1]\n        # Click on 'Start New Debate' button to initiate a new debate session\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to try to reveal the debate configuration form or any interactive elements to proceed with debate setup.\n        await page.mouse.wheel(0, 200)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Glicko-2 Algorithm Verified').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The dual scoring system did not correctly compute and update Crowd Elo and AI Quality scores using the Glicko-2 algorithm, or controversy and Charismatic Liar Index metrics are missing or incorrect.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819086059041//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:07.999Z",
    "modified": "2025-11-22T13:44:46.188Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "8835a98e-b81f-4901-90f4-a3172260acc8",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC003-Prediction Market Betting and Payout Workflow",
    "description": "Ensure the prediction market allows users to bet virtual DebatePoints with dynamic odds and that payouts and Superforecaster badges are correctly assigned post-debate.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Authenticate user and verify DebatePoints balance.\n        frame = context.pages[-1]\n        # Click on 'Start New Debate' to proceed to login or debate creation where user authentication might be required.\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Superforecaster Badge Awarded!').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The prediction market test did not complete successfully. Expected to see 'Superforecaster Badge Awarded!' indicating correct payout and badge assignment, but it was not found on the page.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/176381907497221//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:08.018Z",
    "modified": "2025-11-22T13:44:35.106Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "7cdb61e7-740a-46ed-9e01-3fc1810e5752",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC004-Fact-Checking Agent Integration",
    "description": "Verify the fact-checking agent accurately identifies factual claims in debate arguments, queries external APIs, and displays correct fact-check badges in real-time.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Start New Debate' to initiate a debate including factual statements for verification.\n        frame = context.pages[-1]\n        # Click on 'Start New Debate' button to start a new debate.\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Fact-Check Badge Verified').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Fact-checking agent did not identify factual claims or display fact-check badges as expected during the debate.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819073854043//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:08.029Z",
    "modified": "2025-11-22T13:44:33.999Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "8ee030ef-abd6-416d-a957-d7003ca6b5a0",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC005-Authentication System with OAuth and Anonymous Voting",
    "description": "Test user authentication flow via OAuth providers and ensure anonymous voting is allowed with proper session management.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Locate and click on a login or sign-in button to attempt login using all supported OAuth providers.\n        frame = context.pages[-1]\n        # Click on the AI Debate Arena logo or area to check if it leads to login or shows login options.\n        elem = frame.locator('xpath=html/body/nav/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'Start New Debate' button (index 7) to see if it leads to a login or authentication page.\n        frame = context.pages[-1]\n        # Click 'Start New Debate' button to check if it leads to login or authentication options.\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=OAuth Login Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: User authentication via OAuth providers did not succeed as expected. The test plan requires verifying successful authentication, session creation, and user redirection, but these were not confirmed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819145520085//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:08.043Z",
    "modified": "2025-11-22T13:45:45.672Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "114088f0-42d4-4d7c-8e95-ee548853a152",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC006-Rate Limiting and Anomalous Voting Detection",
    "description": "Validate that rate limiting blocks excessive requests and anomalous voting behavior triggers detection and prevention mechanisms.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Send rapid successive API requests exceeding rate limits to test rate limiting.\n        await page.goto('http://localhost:3000/api/vote', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate back to homepage and find the voting interface or API method to send rapid successive vote requests.\n        frame = context.pages[-1]\n        # Click Home link to go back to homepage\n        elem = frame.locator('xpath=html/body/nav/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'AI Debate Arena' link at index 0 to navigate to the homepage or main dashboard.\n        frame = context.pages[-1]\n        # Click 'AI Debate Arena' link to try to navigate to homepage or main dashboard\n        elem = frame.locator('xpath=html/body/nav/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Rate Limit Exceeded').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Rate limiting did not block excessive requests or anomalous voting behavior was not detected and prevented as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819110803931//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:08.054Z",
    "modified": "2025-11-22T13:45:10.953Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "9c2a053a-1f3a-44ed-aa47-bfa8142ae85b",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC007-Debate Viewer UI with Streaming and Voting Interfaces",
    "description": "Check debate viewer displays real-time streaming arguments, fact-check badges, RCR phase labels, and allows voting accurately.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Example' to load an active debate for testing real-time streaming and other features.\n        frame = context.pages[-1]\n        # Click on 'Example' to load an active debate in the viewer\n        elem = frame.locator('xpath=html/body/nav/div/div/div/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking 'New Debate' link to see if it allows loading or creating an active debate for testing.\n        frame = context.pages[-1]\n        # Click on 'New Debate' to try loading or creating an active debate\n        elem = frame.locator('xpath=html/body/nav/div/div/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Streaming argument with flawless synchronization').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Real-time streaming arguments, fact-check badges, RCR phase labels, and voting features did not function as expected in the debate viewer.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819140798781//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:08.061Z",
    "modified": "2025-11-22T13:45:40.951Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "d71fd10a-5f01-4aa4-9a08-232a3cef8b1d",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC008-Leaderboard Sorting, Filtering and Details",
    "description": "Ensure the leaderboard supports sorting by multiple criteria, filtering by model/topic, and displays detailed statistics correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the Leaderboard link or button to navigate to the leaderboard page.\n        frame = context.pages[-1]\n        # Click on the 'Leaderboard' link in the top navigation to go to the leaderboard page.\n        elem = frame.locator('xpath=html/body/nav/div/div/div/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'View Leaderboard' button (index 8) on the homepage to navigate to the leaderboard page, or report the issue if it fails.\n        frame = context.pages[-1]\n        # Click on the 'View Leaderboard' button on the homepage to navigate to the leaderboard page.\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Leaderboard Sorting by Crowd Elo AI Quality Controversy Charismatic Liar Index').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The leaderboard sorting by multiple criteria (Crowd Elo, AI Quality, Controversy, Charismatic Liar Index) did not execute as expected, or the sorting order did not change accordingly.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819141328337//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:08.068Z",
    "modified": "2025-11-22T13:45:41.482Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "0c2bb613-c1d7-4680-ae30-a03335f1beb7",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC009-User Dashboard Personal Statistics and Voting History",
    "description": "Verify authenticated users can access personal statistics, review their voting history, prediction accuracy, and view DebatePoints balance and badges.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on login or user account access to authenticate.\n        frame = context.pages[-1]\n        # Click on AI Debate Arena logo or top left to check if it leads to login or user account access.\n        elem = frame.locator('xpath=html/body/nav/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access Denied: Unauthorized User').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Authenticated users could not access personal statistics, voting history, DebatePoints balance, or badges as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819087107751//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:08.075Z",
    "modified": "2025-11-22T13:44:47.248Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "54f16158-97b4-45e0-be13-408dab8f79e5",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC010-Topic Submission, Approval, and Auto-Replenishment",
    "description": "Test topic management flow including topic submission by users, admin approval process, and automatic replenishment of topics when inventory is low.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to topic submission form to submit a new debate topic.\n        frame = context.pages[-1]\n        # Click on 'New Debate' to start the topic submission process\n        elem = frame.locator('xpath=html/body/nav/div/div/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'Start New Debate' button on the main page to access the topic submission form.\n        frame = context.pages[-1]\n        # Click on 'Start New Debate' button on the main page\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Topic Submission Failed: Please try again later').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The topic management flow did not complete successfully as the test plan execution failed. Immediate failure triggered to halt further testing.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819143813939//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:08.082Z",
    "modified": "2025-11-22T13:45:43.971Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "d6a767bc-a677-4371-b5a7-848c28ec897d",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC011-API Endpoint Validation and Security",
    "description": "Ensure all API endpoints for debate management, voting, leaderboards, predictions, topics, and health checks respond correctly with appropriate data, validation, and security measures.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-11-22T13:42:08.089Z",
    "modified": "2025-11-22T13:42:08.089Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "9b5e512d-8c75-48a8-b9c3-5f1f81144375",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC012-Performance Under Load and Caching Effectiveness",
    "description": "Test system responsiveness and UI load times under expected concurrent user load and validate caching reduces redundant database queries.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Simulate concurrent users accessing debates, voting, and leaderboard views.\n        frame = context.pages[-1]\n        # Click on 'New Debate' to access debate configuration and simulate user access.\n        elem = frame.locator('xpath=html/body/nav/div/div/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Performance Optimization Achieved').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: System responsiveness and UI load times did not meet performance targets under concurrent user load, or caching did not reduce redundant database queries as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819080257884//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:08.096Z",
    "modified": "2025-11-22T13:44:40.396Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "0dc5be81-fdde-49ab-8fe5-3d8b22e9bb25",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC013-Theme Toggle and UI Accessibility Compliance",
    "description": "Verify dark/light theme toggle works correctly with system preference detection and persistence and UI components meet WCAG 2.1 AA accessibility guidelines.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-11-22T13:42:08.103Z",
    "modified": "2025-11-22T13:42:08.103Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "25ed8f99-6c43-4cd6-a219-c8cf7d638c9b",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC014-Error Handling and Recovery in Debate Lifecycle",
    "description": "Ensure global error boundaries catch runtime errors gracefully and provide recovery options in the debate lifecycle such as state recovery and transcript availability.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click 'Start New Debate' to initiate a debate and prepare to trigger controlled runtime errors.\n        frame = context.pages[-1]\n        # Click 'Start New Debate' button to initiate a new debate session\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Unexpected System Failure Detected').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The global error boundaries did not catch runtime errors gracefully or provide recovery options as expected during the debate lifecycle.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819073928118//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:08.110Z",
    "modified": "2025-11-22T13:44:34.053Z"
  },
  {
    "projectId": "4bf2614a-2473-429a-a2f8-f84332d66ff0",
    "testId": "54df36df-2dc7-4be4-a840-a111b9eb2971",
    "userId": "14e81438-d0a1-7031-4b70-5c5914d1172a",
    "title": "TC015-Session Fingerprinting and Spending Cap Enforcement",
    "description": "Test session fingerprinting correctly distinguishes users and spending caps prevent excessive cost accumulation during debate participation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Initiate multiple sessions from different devices/browsers to generate fingerprints.\n        frame = context.pages[-1]\n        # Click 'Start New Debate' to begin a new debate session for fingerprinting test\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Unique Fingerprint Verified').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test session fingerprinting did not correctly distinguish users or the spending cap did not prevent excessive cost accumulation during debate participation.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/14e81438-d0a1-7031-4b70-5c5914d1172a/1763819078247383//tmp/test_task/result.webm",
    "created": "2025-11-22T13:42:08.118Z",
    "modified": "2025-11-22T13:44:38.426Z"
  }
]
